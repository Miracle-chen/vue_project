<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <meta name="theme-color" content="#000000">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
</head>

<body>
    <div id="app">
        <!-- 声明式渲染： 采用简单的模板语法，声明式地将数据渲染到的DOM中 -->
        <!-- 文本插值 -->
        {{ message }}
        <!-- v-bind 绑定属性上, 语法糖： : -->
        <h1 :title="h1Title">vue</h1>
        <!-- 绑定到DOM结构  -->
        <p v-if="showP">p标签</p>
        <!-- v-for 遍历数据 -->
        <ul>
            <li v-for="value in list">{{ value }}</li>
        </ul>
        <!-- v-model实现数据双向绑定 -->
        <input type="" name="" value="" v-model="inputData">
        <div>{{ inputData }}</div>
        <!-- v-on绑定方法事件， 语法糖： @click -->
        <button v-on:click="btnClick">按钮</button>
        
        <!-- 注册组件 -->
        <ol>
            <!--  用 v-bind 将代办的事项传递到子组件中 -->
            <todo-item 
                v-for="item in groceryList" 
                v-bind:todo="item" 
                v-bind:key=" item.id " 
            />
        </ol>

        <hr>
        <h3>计算属性computed</h3>
        <div> 初始值：{{ message }} </div>
        <div>
            翻转后的值（计算属性）： {{ reversedMessage }}
        </div>
        <div>
            翻转后的值（函数方法）： {{ reversedMessageFunc() }}
        </div>

        <hr>
        <h3>侦听属性watch</h3>
        <div> {{ firstName }} - {{ lastName }} - {{ fullName }} </div>
    </div>
</body>

<script>
    // 定义组件
    let com = Vue.component('todo-item', {
        // 在此处接收由父组件传递进来的参数
        props: ['todo'],
        template: '<li>{{ todo.text }}</li>'
    })
    // 可以再控制台 通过更改 app.message 的方式，来更改页面显示。
    let app = new Vue({
        el: '#app',
        data: {
            message: 'hello world',
            h1Title: 'wo shi h1 de title' + new Date().toLocaleString(),
            showP: false,
            list: ['深入浅出es6', 'vue开发指南'],
            inputData: '',
            groceryList: [
                { id: 0, text: '蔬菜' },
                { id: 1, text: '奶酪' },
            ],

            firstName: 'Foo',
            lastName: 'Bar',
            // fullName: 'Foo Bar'
        },
        methods: {
            // 使用箭头函数，this指向全局， 使用普通函数， this指向app实例。
            btnClick: function () {
                this.list.push(new Date().getTime());
            },
            // 函数方法-
            reversedMessageFunc:function(){
                return this.message.split('').reverse().join('');
            }
        },
        // 计算属性
        computed:{
            reversedMessage:function(){
                return this.message.split('').reverse().join('');
            },
            // 计算属性默认有一个getter，可以自定义一个setter
            fullName: {
                get: function(){
                    return this.firstName + ' ' + this.lastName;
                },
                set: function(newValue){
                    var names = newValue.split(' ');
                    this.firstName = names[0]
                    this.lastName = names[names.length - 1]
                }
            }
        },
        watch:{
            // firstName: function(val){
            //     this.fullName = val + this.lastName;
            // },
            // lastName: function(val){
            //     this.fullName = this.firstName + val;
            // }
        }
    });

    
    // Vue 实例还暴露了一些有用的实例 property 与方法， 例如 ：
    // 实例外获取实例的数据
    app.$data;
    // 获取根节点
    app.$el === document.getElementById('app'); 
    // 实例外监听数据的变化
    app.$watch('message', function(){
        console.log( 'message changed' );
    })

    /*
        计算属性缓存和方法

        计算属性是有基于其响应式依赖进行缓存的，只要其依赖的数据没有发生变化，再次访问它的时候，他会将上次缓存的结果立刻返回出去。只有依赖数据发生变化，才会重新计算属性。
        而方法是没有缓存效果的，只要调用了多次，就会执行多次。
        在不需要缓存的时候，可以使用方法定义而不选择计算属性，如存在new Date()的时候，其并不是实例的数据，不存在依赖关系。想要用实时的date，就要采用方法的方式。
    */ 

    /*
        计算属性和侦听属性

        在同等依赖数据个数条件下，使用watch和使用computed是一样的，在一个值依赖多个数据的时候，使用computed比使用watch更加的方便。
        如在上述例子里，获取fullName的时候，使用computed就更加的方便，而使用watch则需要定义多次，会造成代码的重复。
    */ 
</script>

</html>